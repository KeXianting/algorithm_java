package methd_of_programing.array;

/**
 * Created by kentorvalds on 2017/12/26.
 * 有一个无序数组V[N], 请找出该数列中大小相邻的实数的差的最大值,求线性空间和线性时间:
 *
 * 首先就是对数组进行一个排序，然后扫面一遍数据就可以得到结果；但时间复杂度依赖于排序时间复杂度，一般为O(nlog n)
 * 应用桶排序, 时间负责度为O(n)
 *http://blog.csdn.net/leo____wang/article/details/53367723
 *
 * 对于 数组中 n 个数，我们用 n+1 个桶来装，而且在构造这n+1个桶的时候，
 * 需要一点技巧。我们把 用 n （注意：此处用 n ，而不是 n+1 ）来除 max{A} - min{A} ，这样就把数组中 从最大值到最小值 分成了 n 份
 *
 * 把这些元素想象成人，元素值的大小就是人的身高，然后根据每个人的身高，决定某个人应该站在哪一级台阶上。站台阶的规则是这样的：最矮的只能站在地上，最高的则站在最高处。因为一共有 n 个数， 但是却有 n+1 个台阶，所以，中间必然有个台阶是没“人” 站的，当然，可能还有另外的台阶也没站人，但是，此时至少有一个是没有站人的，至少有一个，抽屉原理。，而且，而且，（预警，问题的关键点来了）相邻台阶上的 “人” 的身高的差，不会大于中间隔着空闲台阶的人的身高差！道理很简单，反证一下，如果相邻台阶上人的身高差，超过一个台阶高度的话，那么这两个人站上的台阶就不可能是挨着的。所以，最大的身高差，只能出现在与空闲台阶挨着的左右两个非空闲台阶中。

 好，问题说到这儿，说了一半。另外一个是：我们没有必要将每个元素到放到对应的台阶上，每个台阶上只留下两个值就好，一个最大值，一个最小值。开始的时候，台阶上的最大值和最小值可以都初始化为零。然后更新呢就好。


 好，那么问题到这儿就可以做个了结了。两个相邻元素的最大的差值，就是，空闲台阶的后一个紧挨着的非空闲台阶上的最小值     减去     空间台阶上前一个紧挨着的非空闲台阶上的最大值。注意，不一定只有一个空闲台阶，所以要循环迭代，更新最大的gap
 */
public class MaxGapOfUnorderArray {

    public static void main(String[] args) {

        //int[] a = {9590,5695,4776,5450,9128,2219,4782,5023,3685,54,2688,4716,8175,1012,3079,5574,6336,3755,5328,2925,3825,3443,9253,7427,3809,9360,8809,5885,8944,2048,8170,1285,1223,2186,2969,5342,5076,911,391,1950,2480,1264,9795,45,1763,9169,7526,6225,5571,5805,9468,9383,6885,1576,9810,6544,853,9628,175,4595,5025,8688,9239,975,5370,673,9435,5559,205,744,2146,2597,987,7727,3116,5843,1575,6252,2245,4205,3481,3600,1910,8912,3824,1333,8392,6311,3504,8379,9636,244,5835,1896,4181,5452,617,4850,6326,2381,4524,5502,9970,9919,8138,69,5831,7087,416,8547,5568,4658,7418,2703,837,9223,7926,5703,3623,7347,8297,5270,9026,1913,6588,4362,6278,2129,422,6819,3828,7056,3926,8088,7424,7823,9408,2836,4629,8770,5793,662,269,9958,9569,9321,5095,9075,9883,8858,79,7148,6446,2854,8157,9279,6063,696,236,7060,8070,3431,854,4811,858,2501,9900,6987,5021,6246,8057,3198,2847,2758,4540,5268,7924,6729,8661,9045,8118,6669,5603,5585,9753,8098,2712,6487,2500,7702,7103,9492,7662,7623,671,7095,2214,7512,4991,1712,5238,1874,8203,6442,6785,158,1343,2574,415,6316,8487,3159,2151,5176,3250,1572,7555,188,3098,5595,7337,5693,2928,5179,1251,8417,1235,7807,1733,4618,1664,5007,1589,857,4440,4041,4652,6515,1284,6564,8916,9961,7111,4749,6903,9085,4064,6868,1399,9619,4977,4505,5226,7264,5149,9909,5065,1164,3057,9360,5084,336,4994,9715,7446,8395,7324,6319,9460,464,2259,2183,2365,9115,7768,8529,4445,2349,3414,5595,2768,9367,9366,8874,2052,8875,8481,8528,8631,874,3344,2434,2454,4231,5793,5388,9261,6075,4236,904,3433,7027,7065,3230,8830,6011,830,9467,8512,3098,6858,7226,228,4202,7216,2414,9676,8528,348,7004,8965,7050,4045,5379,9432,6224,8699,3739,9822,1867,1486,9600,6690,930,2807,7584,691,8949,118,9720,1286,3489,5623,1596,8657,7902,63,5136,4851,1111,5665,4060,9291,5156,4845,5331,8544,6089,6574,5618,4406,6850,939,5107,9179,2240,1964,7938,1021,6793,8417,1102,2565,8379,703,7768,8183,5518,9335,3839,1258,8463,589,5209,2419,9296,3570,9351,2648,4734,6006,306,5720,1112,8299,1619,68,1986,279,7750,9680,9980,5407,7364,1275,4493,3118,4026,2670,2072,978,9299,3314,2361,4415,9950,8859,5163,817,4150,7022,891,4788,7405,9288,5527,3923};
        int[] a = {3,1,2,4,9,8,7};
        int c = maxGap(a, a.length);
        System.out.println(c);
    }

    //a = {3,1,2,4,9,8,7}, a中的最大值为9,最小值为1,选取7个桶,每个桶的区间长度为8/7
    //第一个桶:[1,15/7]里面放1,2两个元素; 第二个桶为[15/7,23/7],里面放3;第三个桶为[23/7,31/7]里面放4; 第四个桶[31/7,39/7]为空,第五个桶[39/7,47/7]里面为空
    //第六个桶:[47/7,55/7],里面放7, 第七个桶[55/7,63/7],里面放8,9
    //所以用第六个桶中的最小元素7减去第三个桶里面的最大元素4得到所有最大差值
    public static int maxGap(int[] A, int n) {

        if( A==null || A.length<2){   //感觉这些代码总是忘写，其实还是很有用的,只能说明思维不严谨啊
            return 0;
        }
        int max = A[0];
        int min = A[0];
        //找到最大值和最小值
        for(int i=0;i<n;i++){
            max = Math.max(max, A[i]);
            min = Math.min(min,A[i]);
        }
        if(max==min){           //感觉这些代码总是忘写，其实还是很有用的
            return 0;
        }


        int num =  n+1;//共用n+1个桶来存放，其中大的元素必定放在最后一个桶中
        int[] mins = new int[num];//存放每个桶中的最小值，在向桶中放入元素时，更新此值
        int[] maxs = new int[num];//存放每个桶中的最大值, 在向桶中放入元素时，更新此值
        boolean[] hasNum = new boolean[num]; //用来标记对应下标的桶中是否为空(boolean数组默认初始化为false)


        //向桶中放入元素,每次放入元素时，根据原桶中的状态来更新
        for(int i=0;i<n;i++){
            int tag = bucket(A[i],num,max,min);//得到A[i]的桶号
            mins[tag] = hasNum[tag]?Math.min(mins[tag], A[i]):A[i];
            maxs[tag] = hasNum[tag]?Math.max(maxs[tag], A[i]):A[i];
            hasNum[tag] = true;
        }

//      放好元素后，开始计算最大的差值
        int gap = 0;
        int preMax = 0;//记录前一个桶中的最大值
        int aftMin = 0;//记录后一个桶中的最小值
        int i = 0;
        //num为桶的数量
        while(i<num){   //在n+1 个桶中循环更新 gap的值，每次只在空桶两侧更新，因为首先n个元素，n+1个桶，保证了肯定有空桶，并且最大的差值肯定出现在空桶的两侧非空桶中元素的差值中
            while(i<num && hasNum[i]){   //寻找第一个空桶，因为n+1 个桶存放 n 个元素，肯定会有空桶存在，而最大值，就会出现在空桶中相邻两个桶中元素的差值
                i++;
            }
            if(i>=num)
                break;
            preMax = maxs[--i];
            i++;
            while(i<num && !hasNum[i]){ //在上次找到了空桶的基础上，继续循环，空桶之后的下一个非空的桶，此处因为我们把最大的元素放到了最后一个桶中，所以不用担找不到下一个非空的桶
                i++;
            }
            aftMin = mins[i];
            gap = gap>(aftMin  - preMax)?gap:(aftMin  - preMax);
        }
        return gap;
    }
    //该方法用来计算对应元素的应该放入的桶号
    private static int bucket(long value, long num, long max, long min) {
//      int tag = (int) ((value-min)/((max-min)/(num-1)));  应该避免这种连续除法的表达式，因为每次处的时候都会舍，到最后结果会相差很大
        int tag = (int) ((value-min)*(num-1)/(max-min));
        return tag;
    }

}
